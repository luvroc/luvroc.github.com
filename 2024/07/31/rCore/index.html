<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>rCore-Tutorial follow the riscv trend!!! | uloveRock?</title><meta name="author" content="luvroc"><meta name="copyright" content="luvroc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="rCore-ch1环境执行fn main() &#123;    println!(&quot;hello,world&quot;);&#125;  从修改hello world，使它不用系统自带的依赖开始  修改目标平台目标为裸机平台,没有rust标准库和os支持的系统调用,为了方便换上了rust的core库  # os&#x2F;.cargo&#x2F;config[build]target &#x3D; &quot;ri">
<meta property="og:type" content="article">
<meta property="og:title" content="rCore-Tutorial follow the riscv trend!!!">
<meta property="og:url" content="http://luvroc.github.io/2024/07/31/rCore/">
<meta property="og:site_name" content="uloveRock?">
<meta property="og:description" content="rCore-ch1环境执行fn main() &#123;    println!(&quot;hello,world&quot;);&#125;  从修改hello world，使它不用系统自带的依赖开始  修改目标平台目标为裸机平台,没有rust标准库和os支持的系统调用,为了方便换上了rust的core库  # os&#x2F;.cargo&#x2F;config[build]target &#x3D; &quot;ri">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://q1.qlogo.cn/g?b=qq&nk=2316139590&s=640">
<meta property="article:published_time" content="2024-07-30T18:35:00.000Z">
<meta property="article:modified_time" content="2024-08-11T09:04:38.357Z">
<meta property="article:author" content="luvroc">
<meta property="article:tag" content="Embedded">
<meta property="article:tag" content="Rust">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://q1.qlogo.cn/g?b=qq&nk=2316139590&s=640"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://luvroc.github.io/2024/07/31/rCore/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'rCore-Tutorial follow the riscv trend!!!',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-11 17:04:38'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://q1.qlogo.cn/g?b=qq&amp;nk=2316139590&amp;s=640" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="uloveRock?"><span class="site-name">uloveRock?</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">rCore-Tutorial follow the riscv trend!!!</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-30T18:35:00.000Z" title="发表于 2024-07-31 02:35:00">2024-07-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-11T09:04:38.357Z" title="更新于 2024-08-11 17:04:38">2024-08-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Embedded-system/">Embedded system</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Embedded-system/Rust/">Rust</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="rCore-Tutorial follow the riscv trend!!!"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="rCore-ch1"><a href="#rCore-ch1" class="headerlink" title="rCore-ch1"></a>rCore-ch1</h3><h4 id="环境执行"><a href="#环境执行" class="headerlink" title="环境执行"></a>环境执行</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从修改hello world，使它不用系统自带的依赖开始</p>
<ol>
<li>修改目标平台<br>目标为裸机平台,没有rust标准库和os支持的系统调用,为了方便换上了rust的core库</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/.cargo/config</span><br><span class="line">[build]</span><br><span class="line">target = <span class="string">&quot;riscv64gc-unknown-none-elf&quot;</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>移除标准库依赖<br>在main.rs中修改如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">	<span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同级目录新建一个lang_items.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(_info: &amp;PanicInfo) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此便移除了所有标准库依赖,可尝试<code>cargo build</code>看看全新的程序了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">file /path/to/elf</span><br><span class="line"><span class="comment"># 可看文件格式</span></span><br><span class="line">rust-readobj -h /path/to/elf</span><br><span class="line"><span class="comment"># 可看详细的文件头信息</span></span><br><span class="line">rust-objdump -S /path/to/elf</span><br><span class="line"><span class="comment"># 可看反汇编导出的汇编程序</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/..%5Cpics%5Cimage-20240731152144771.png" alt="image-20240731152144771"></p>
<h4 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h4><p>先前的main.rs里已经有了程序入口,可尝试给<code>qemu-riscv64</code>跑一个看看</p>
<p><img src="/../pics/image-20240731183935657.png" alt="image-20240731183935657"></p>
<p>第一次跑段错误了,后面跟教程修改了一些才能够正常运行</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        core::arch::asm!(</span><br><span class="line">            <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) args[<span class="number">0</span>] =&gt; ret,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) args[<span class="number">1</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) args[<span class="number">2</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) id,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个神秘的函数,它通过使用内联汇编方便地使用core库提供给的系统调用.比如目前执行环境缺少一个退出机制:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SYSCALL_EXIT: <span class="type">usize</span> = <span class="number">93</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//define syscall</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>,args: [<span class="type">usize</span>;<span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_exit</span>(xstate: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_EXIT, [xstate <span class="keyword">as</span> <span class="type">usize</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">sys_exit</span>(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再传给qemu就能正常运行,还能通过$?参数接受退出码</p>
<p>如果要实现Stdout,也是类似的,复杂一点:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> core::fmt;</span><br><span class="line"><span class="keyword">use</span> core::fmt::Write;</span><br><span class="line"><span class="keyword">const</span> SYSCALL_WRITE: <span class="type">usize</span> = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_write</span>(fd: <span class="type">usize</span>, buffer: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">  <span class="title function_ invoke__">syscall</span>(SYSCALL_WRITE, [fd, buffer.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> <span class="type">usize</span>, buffer.<span class="title function_ invoke__">len</span>()])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再基于这个封装实现stdout</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stdout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Write</span> <span class="keyword">for</span> <span class="title class_">Stdout</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_str</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">sys_write</span>(<span class="number">1</span>, s.<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">print</span>(args: fmt::Arguments) &#123;</span><br><span class="line">    Stdout.<span class="title function_ invoke__">write_fmt</span>(args).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实此时已经可以通过print输出字符串了,就是类型上会有点别扭(毕竟没有标准库)</p>
<p>再来点看不懂的格式化宏</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> print &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>($fmt $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>(<span class="built_in">concat!</span>($fmt, <span class="string">&quot;\n&quot;</span>) $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以看看输出效果了</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">sys_exit</span>(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../pics/image-20240731191217937.png" alt="image-20240731191217937"></p>
<p>此时如果想用objdump看看的话,就会发现多了特别多的依赖之类,而上面写的源码编译出来的东西(除了宏,宏的编译结果我没法直接看出来)只占其中一部分,我的objdump结果总共2000行,其中300行左右是我们的源码</p>
<h4 id="裸机环境"><a href="#裸机环境" class="headerlink" title="裸机环境"></a>裸机环境</h4><p>用qemu的&#96;qemu-system-riscv64模拟risc-v 64构建裸机环境,加载内核的命令:</p>
<ul>
<li><code>-bios $(bootloader)</code>加载bootloader,即rustSBI,</li>
<li><code>-device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA)</code>表示硬件内存中的特定位置即<code>$(KERNEL_ENTRY_PA)</code>放置了操作系统的二进制程序<code>$(KERNEL_BIN)</code>,entry_pa值是0x80200000</li>
</ul>
<p>当我们执行包含上述启动参数的 qemu-system-riscv64 软件，就意味给这台虚拟的 RISC-V64 计算机加电了。 此时，CPU 的其它通用寄存器清零，而 PC 会指向 <code>0x1000</code> 的位置，这里有固化在硬件中的一小段引导代码， 它会很快跳转到 <code>0x80000000</code> 的 RustSBI 处。 RustSBI完成硬件初始化后，会跳转到 <code>$(KERNEL_BIN)</code> 所在内存位置 <code>0x80200000</code> 处， 执行操作系统的第一条指令。</p>
<p>当在裸机环境运行时,需要有关机功能</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bootloader/rustsbi-qemu.bin 直接添加的SBI规范实现的二进制代码，给操作系统提供基本支持服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/sbi.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sbi_call</span>(which: <span class="type">usize</span>, arg0: <span class="type">usize</span>, arg1: <span class="type">usize</span>, arg2: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line"> <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>;</span><br><span class="line">  <span class="keyword">unsafe</span> &#123;</span><br><span class="line">      core::arch::asm!(</span><br><span class="line">          <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SBI_SHUTDOWN: <span class="type">usize</span> = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">shutdown</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">sbi_call</span>(SBI_SHUTDOWN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;It should shutdown!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/main.rs</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">shutdown</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“ecall”和上以迎接不同在于特权级:</p>
<p>User Mode &lt; Supervisor Mode &lt; Machine Mode,分别对应”应用程序\操作系统\RustSBI”</p>
<p>编译结果如下:(ctlr C无法退出,用了类似kill的工具)</p>
<p><img src="/../pics/image-20240803214636705.png" alt="image-20240803214636705"></p>
<p>用rust-readobj看:(valid是后面通过qemu正常自动退出的结果,invalid是目前这个卡住的)</p>
<p><img src="/../pics/image-20240803215319416.png" alt="image-20240803215319416"></p>
<p>发现其入口地址不是 RustSBI 约定的 <code>0x80200000</code>,需要修改内存布局</p>
<ol>
<li>增加链接脚本: 首先在cargo的配置文件中加入自己的链接脚本:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// os/.cargo/config</span><br><span class="line">[build]</span><br><span class="line">target = &quot;riscv64gc-unknown-none-elf&quot;</span><br><span class="line"></span><br><span class="line">[target.riscv64gc-unknown-none-elf]</span><br><span class="line">rustflags = [</span><br><span class="line">    &quot;-Clink-arg=-Tsrc/linker.ld&quot;, &quot;-Cforce-frame-pointers=yes&quot;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在os&#x2F;src&#x2F;新建一linker.ld:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH(riscv)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">BASE_ADDRESS = 0x80200000;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = BASE_ADDRESS;</span><br><span class="line">    skernel = .;</span><br><span class="line"></span><br><span class="line">    stext = .;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    etext = .;</span><br><span class="line">    srodata = .;</span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    erodata = .;</span><br><span class="line">    sdata = .;</span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data .data.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    edata = .;</span><br><span class="line">    .bss : &#123;</span><br><span class="line">        *(.bss.stack)</span><br><span class="line">        sbss = .;</span><br><span class="line">        *(.bss .bss.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    ebss = .;</span><br><span class="line">    ekernel = .;</span><br><span class="line"></span><br><span class="line">    /DISCARD/ : &#123;</span><br><span class="line">        *(.eh_frame)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化栈空间</li>
</ol>
<p>再在同一文件夹新建一个entry.asm,用以初始化栈空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    .section .text.entry</span><br><span class="line">    .globl _start</span><br><span class="line">_start:</span><br><span class="line">    la sp, boot_stack_top</span><br><span class="line">    call rust_main</span><br><span class="line"></span><br><span class="line">    .section .bss.stack</span><br><span class="line">    .globl boot_stack</span><br><span class="line">boot_stack:</span><br><span class="line">    .space 4096 * 16</span><br><span class="line">    .globl boot_stack_top</span><br><span class="line">boot_stack_top:</span><br></pre></td></tr></table></figure>

<p>可以看到此时在初始化空间之后直接call了一个新函数<code>rust_main</code>,于是我们也要在main.rs内补充同名函数以满足</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">core::arch::global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;entry.asm&quot;</span>));</span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rust_main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">shutdown</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再把原本的_start注释掉</p>
<ol start="3">
<li>再次编译并生成和运行,可以看到qemu成功退出</li>
</ol>
<p><img src="/../pics/image-20240803220838568.png" alt="image-20240803220838568"></p>
<p>再清空一下.bss段,关于为什么<img src="/../pics/image-20240803221451061.png" alt="image-20240803221451061"></p>
<p>清除的方法即增加在main.rs中的clear_bss()</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/main.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">clear_bss</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">sbss</span>();</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">ebss</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    (sbss <span class="keyword">as</span> <span class="type">usize</span>..ebss <span class="keyword">as</span> <span class="type">usize</span>).for_each(|a| &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (a <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>).<span class="title function_ invoke__">write_volatile</span>(<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rust_main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="title function_ invoke__">shutdown</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再经过一些对原项目的加工(Ctrl cv),终于能hello world了!</p>
<p><img src="/../pics/image-20240803232800786.png" alt="image-20240803232800786"></p>
<h3 id="rCore-ch2"><a href="#rCore-ch2" class="headerlink" title="rCore-ch2"></a>rCore-ch2</h3><h4 id="todo-What？"><a href="#todo-What？" class="headerlink" title="todo What？"></a>todo What？</h4><p>说实话我在看到这一章的时候挺茫然的，满篇的东西都是在介绍，不知道我要干什么。</p>
<p>那么来总结一下这一章书上的内容先：</p>
<blockquote>
<ol>
<li>批处理系统：多个程序打包到一起输入计算机，程序结束自动执行下一个。为避免出错时整个环境崩溃，引入特权级，分开用户、内核。</li>
<li>应用程序： 项目文件里准备了bin文件夹对应各个应用程序。每个程序在main函数内实现了用户程序的功能。使用的依赖对应lib.rs（类似于一个标准库）。lib.rs中定义了<code>_start</code>用于初始化应用程序</li>
<li>批处理: 内核通过<code>link_app.S</code>获知应用程序的数量和位置,通过<code>AppManager</code>来加载应用程序的二进制码.加载时需要清除缓存,清空内存,将二进制程序复制到正确位置.</li>
<li>特权转换: 特权被一些对应用的切换和监控操作需要,比如初始化,处理系统调用,应用出错的处理程序,结束程序时的切换</li>
</ol>
</blockquote>
<p>在看看程序跑一遍的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[rustsbi] RustSBI version 0.3.0-alpha.4, adapting to RISC-V SBI v1.0.0</span><br><span class="line">.______       __    __      _______.___________.  _______..______   __</span><br><span class="line">|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |</span><br><span class="line">|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |</span><br><span class="line">|      /     |  |  |  |    \   \       |  |      \   \    |   _  &lt; |  |</span><br><span class="line">|  |\  \----.|  `--&#x27;  |.----)   |      |  |  .----)   |   |  |_)  ||  |</span><br><span class="line">| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|</span><br><span class="line">[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.2</span><br><span class="line">[rustsbi] Platform Name      : riscv-virtio,qemu</span><br><span class="line">[rustsbi] Platform SMP       : 1</span><br><span class="line">[rustsbi] Platform Memory    : 0x80000000..0x88000000</span><br><span class="line">[rustsbi] Boot HART          : 0</span><br><span class="line">[rustsbi] Device Tree Region : 0x87000000..0x87000ef2</span><br><span class="line">[rustsbi] Firmware Address   : 0x80000000</span><br><span class="line">[rustsbi] Supervisor Address : 0x80200000</span><br><span class="line">[rustsbi] pmp01: 0x00000000..0x80000000 (-wr)</span><br><span class="line">[rustsbi] pmp02: 0x80000000..0x80200000 (---)</span><br><span class="line">[rustsbi] pmp03: 0x80200000..0x88000000 (xwr)</span><br><span class="line">[rustsbi] pmp04: 0x88000000..0x00000000 (-wr)</span><br><span class="line">[kernel] Hello, world!</span><br><span class="line">[ INFO] [kernel] .data [0x8020b000, 0x80228000)</span><br><span class="line">[ WARN] [kernel] boot_stack top=bottom=0x80238000, lower_bound=0x80228000</span><br><span class="line">[ERROR] [kernel] .bss [0x80238000, 0x80239000)</span><br><span class="line">[kernel] num_app = 7</span><br><span class="line">[kernel] app_0 [0x8020b048, 0x8020f0f0)</span><br><span class="line">[kernel] app_1 [0x8020f0f0, 0x80213198)</span><br><span class="line">[kernel] app_2 [0x80213198, 0x80217240)</span><br><span class="line">[kernel] app_3 [0x80217240, 0x8021b2e8)</span><br><span class="line">[kernel] app_4 [0x8021b2e8, 0x8021f390)</span><br><span class="line">[kernel] app_5 [0x8021f390, 0x80223438)</span><br><span class="line">[kernel] app_6 [0x80223438, 0x802274e0)</span><br><span class="line">[kernel] Loading app_0</span><br><span class="line">[kernel] PageFault in application, kernel killed it.</span><br><span class="line">[kernel] Loading app_1</span><br><span class="line">[kernel] IllegalInstruction in application, kernel killed it.</span><br><span class="line">[kernel] Loading app_2</span><br><span class="line">[kernel] IllegalInstruction in application, kernel killed it.</span><br><span class="line">[kernel] Loading app_3</span><br><span class="line">Hello, world from user mode program!</span><br><span class="line">[kernel] Loading app_4</span><br><span class="line">power_3 [10000/200000]</span><br><span class="line">power_3 [20000/200000]</span><br><span class="line">power_3 [30000/200000]</span><br><span class="line">power_3 [40000/200000]</span><br><span class="line">power_3 [50000/200000]</span><br><span class="line">power_3 [60000/200000]</span><br><span class="line">power_3 [70000/200000]</span><br><span class="line">power_3 [80000/200000]</span><br><span class="line">power_3 [90000/200000]</span><br><span class="line">power_3 [100000/200000]</span><br><span class="line">power_3 [110000/200000]</span><br><span class="line">power_3 [120000/200000]</span><br><span class="line">power_3 [130000/200000]</span><br><span class="line">power_3 [140000/200000]</span><br><span class="line">power_3 [150000/200000]</span><br><span class="line">power_3 [160000/200000]</span><br><span class="line">power_3 [170000/200000]</span><br><span class="line">power_3 [180000/200000]</span><br><span class="line">power_3 [190000/200000]</span><br><span class="line">power_3 [200000/200000]</span><br><span class="line">3^200000 = 871008973(MOD 998244353)</span><br><span class="line">Test power_3 OK!</span><br><span class="line">[kernel] Loading app_5</span><br><span class="line">power_5 [10000/140000]</span><br><span class="line">power_5 [20000/140000]</span><br><span class="line">power_5 [30000/140000]</span><br><span class="line">power_5 [40000/140000]</span><br><span class="line">power_5 [50000/140000]</span><br><span class="line">power_5 [60000/140000]</span><br><span class="line">power_5 [70000/140000]</span><br><span class="line">power_5 [80000/140000]</span><br><span class="line">power_5 [90000/140000]</span><br><span class="line">power_5 [100000/140000]</span><br><span class="line">power_5 [110000/140000]</span><br><span class="line">power_5 [120000/140000]</span><br><span class="line">power_5 [130000/140000]</span><br><span class="line">power_5 [140000/140000]</span><br><span class="line">5^140000 = 386471875(MOD 998244353)</span><br><span class="line">Test power_5 OK!</span><br><span class="line">[kernel] Loading app_6</span><br><span class="line">power_7 [10000/160000]</span><br><span class="line">power_7 [20000/160000]</span><br><span class="line">power_7 [30000/160000]</span><br><span class="line">power_7 [40000/160000]</span><br><span class="line">power_7 [50000/160000]</span><br><span class="line">power_7 [60000/160000]</span><br><span class="line">power_7 [70000/160000]</span><br><span class="line">power_7 [80000/160000]</span><br><span class="line">power_7 [90000/160000]</span><br><span class="line">power_7 [100000/160000]</span><br><span class="line">power_7 [110000/160000]</span><br><span class="line">power_7 [120000/160000]</span><br><span class="line">power_7 [130000/160000]</span><br><span class="line">power_7 [140000/160000]</span><br><span class="line">power_7 [150000/160000]</span><br><span class="line">power_7 [160000/160000]</span><br><span class="line">7^160000 = 667897727(MOD 998244353)</span><br><span class="line">Test power_7 OK!</span><br><span class="line">All applications completed!</span><br></pre></td></tr></table></figure>

<p>再跟着代码看看运行的过程经历了什么(也就是看看源码,不想自己敲的懒狗发言XD)</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/main.rs</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rust_main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">stext</span>(); <span class="comment">// begin addr of text segment</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">etext</span>(); <span class="comment">// end addr of text segment</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">srodata</span>(); <span class="comment">// start addr of Read-Only data segment</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">erodata</span>(); <span class="comment">// end addr of Read-Only data ssegment</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">sdata</span>(); <span class="comment">// start addr of data segment</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">edata</span>(); <span class="comment">// end addr of data segment</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">sbss</span>(); <span class="comment">// start addr of BSS segment</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">ebss</span>(); <span class="comment">// end addr of BSS segment</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">boot_stack_lower_bound</span>(); <span class="comment">// stack lower bound</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">boot_stack_top</span>(); <span class="comment">// stack top</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    logging::<span class="title function_ invoke__">init</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;[kernel] Hello, world!&quot;</span>);</span><br><span class="line">    trace!(</span><br><span class="line">        <span class="string">&quot;[kernel] .text [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>,</span><br><span class="line">        stext <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">        etext <span class="keyword">as</span> <span class="type">usize</span></span><br><span class="line">    );</span><br><span class="line">    debug!(</span><br><span class="line">        <span class="string">&quot;[kernel] .rodata [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>,</span><br><span class="line">        srodata <span class="keyword">as</span> <span class="type">usize</span>, erodata <span class="keyword">as</span> <span class="type">usize</span></span><br><span class="line">    );</span><br><span class="line">    info!(</span><br><span class="line">        <span class="string">&quot;[kernel] .data [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>,</span><br><span class="line">        sdata <span class="keyword">as</span> <span class="type">usize</span>, edata <span class="keyword">as</span> <span class="type">usize</span></span><br><span class="line">    );</span><br><span class="line">    warn!(</span><br><span class="line">        <span class="string">&quot;[kernel] boot_stack top=bottom=&#123;:#x&#125;, lower_bound=&#123;:#x&#125;&quot;</span>,</span><br><span class="line">        boot_stack_top <span class="keyword">as</span> <span class="type">usize</span>, boot_stack_lower_bound <span class="keyword">as</span> <span class="type">usize</span></span><br><span class="line">    );</span><br><span class="line">    error!(<span class="string">&quot;[kernel] .bss [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, sbss <span class="keyword">as</span> <span class="type">usize</span>, ebss <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    trap::<span class="title function_ invoke__">init</span>();</span><br><span class="line">    batch::<span class="title function_ invoke__">init</span>();</span><br><span class="line">    batch::<span class="title function_ invoke__">run_next_app</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>make run LOG=INFO</code>的指令,可以看到从helloworld到error这三行是这里的输出.main之后是两个init和一个run_next</p>
<h4 id="CodeReading-CorePart"><a href="#CodeReading-CorePart" class="headerlink" title="CodeReading-CorePart"></a>CodeReading-CorePart</h4><h5 id="1-trap"><a href="#1-trap" class="headerlink" title="1.trap"></a>1.trap</h5><p><img src="/../pics/image-20240808221732668.png" alt="image-20240808221732668"></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/trap/mod.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">__alltraps</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        stvec::<span class="title function_ invoke__">write</span>(__alltraps <span class="keyword">as</span> <span class="type">usize</span>, TrapMode::Direct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的init原谅我不是很明白.在同级文件夹找到了<code>__alltraps</code>的具体内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># os/src/trap/trap.S</span><br><span class="line">__alltraps:</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    # now sp-&gt;kernel stack, sscratch-&gt;user stack</span><br><span class="line">    # allocate a TrapContext on kernel stack</span><br><span class="line">    addi sp, sp, -34*8</span><br><span class="line">    # save general-purpose registers</span><br><span class="line">    sd x1, 1*8(sp)</span><br><span class="line">    # skip sp(x2), we will save it later</span><br><span class="line">    sd x3, 3*8(sp)</span><br><span class="line">    # skip tp(x4), application does not use it</span><br><span class="line">    # save x5~x31</span><br><span class="line">    .set n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        SAVE_GP %n</span><br><span class="line">        .set n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    # we can use t0/t1/t2 freely, because they were saved on kernel stack</span><br><span class="line">    csrr t0, sstatus</span><br><span class="line">    csrr t1, sepc</span><br><span class="line">    sd t0, 32*8(sp)</span><br><span class="line">    sd t1, 33*8(sp)</span><br><span class="line">    # read user stack from sscratch and save it on the kernel stack</span><br><span class="line">    csrr t2, sscratch</span><br><span class="line">    sd t2, 2*8(sp)</span><br><span class="line">    # set input argument of trap_handler(cx: &amp;mut TrapContext)</span><br><span class="line">    mv a0, sp</span><br><span class="line">    call trap_handler</span><br></pre></td></tr></table></figure>

<p>感谢逐行的注释</p>
<p><img src="/../pics/image-20240808215516481.png" alt="image-20240808215516481"></p>
<p>从    <code>csrrw sp, sscratch, sp</code>可知这个函数执行时将从用户态转向内核态,此时在做用户栈到内核栈的转换,分配空间存储trapText,保存一些寄存器的值到内核栈上:比如x1,x3,x5~x31,t0(对应<code>sstatus</code> 寄存器,包含当前 CPU 的状态),t1(对应<code>sepc</code> 寄存器,包含trap发生时的程序计数器值),t2(对应与用户空间的sp),最后将sp的值赋给a0,传给<code>trap_handler</code>.总的来说就是在初始化处理trap的条件和特权转换</p>
<p>返回看os&#x2F;trap&#x2F;mod.rs之中的<code>stvec::write(__alltraps as usize, TrapMode::Direct);</code>这一行,将这个trap处理的程序地址写入<code>stvec</code>,控制trap处理代码的入口地址.也就是在<code>trap::init();</code>之后,我们可以调用<code>stvec</code>来处理所有的trap了</p>
<h5 id="2-batch"><a href="#2-batch" class="headerlink" title="2.batch"></a>2.batch</h5><p>这一小节的内容能和tutorial书中实现批处理系统这一节对应上.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/batch.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">print_app_info</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">print_app_info</span>() &#123;</span><br><span class="line">    APP_MANAGER.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">print_app_info</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> APP_MANAGER: UPSafeCell&lt;AppManager&gt; = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        UPSafeCell::<span class="title function_ invoke__">new</span>(&#123;</span><br><span class="line">            <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">fn</span> <span class="title function_">_num_app</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">num_app_ptr</span> = _num_app <span class="keyword">as</span> <span class="type">usize</span> <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">usize</span>;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">num_app</span> = num_app_ptr.<span class="title function_ invoke__">read_volatile</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">app_start</span>: [<span class="type">usize</span>; MAX_APP_NUM + <span class="number">1</span>] = [<span class="number">0</span>; MAX_APP_NUM + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">app_start_raw</span>: &amp;[<span class="type">usize</span>] =</span><br><span class="line">                core::slice::<span class="title function_ invoke__">from_raw_parts</span>(num_app_ptr.<span class="title function_ invoke__">add</span>(<span class="number">1</span>), num_app + <span class="number">1</span>);</span><br><span class="line">            app_start[..=num_app].<span class="title function_ invoke__">copy_from_slice</span>(app_start_raw);</span><br><span class="line">            AppManager &#123;</span><br><span class="line">                num_app,</span><br><span class="line">                current_app: <span class="number">0</span>,</span><br><span class="line">                app_start,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看这样一点代码.</p>
<p>这里调用的过程是init -&gt; print__app_info -&gt; APP_MANAGER 实例 -&gt; lazy_static 初始化 -&gt; print_app_info 方法。</p>
<p>下面是涉及到的rust语法</p>
<blockquote>
<p>lazy_static: 给静态变量延迟赋值的宏,在第一次被访问时完成赋值</p>
<p>UPsafeCell: 在单处理器中使用的数据结构,里面包含一个<code>RefCell&lt;T&gt;</code>,通过<code>.exclusive_access()</code>可访问这个数据的可变引用,能防止内部对象被重复借用</p>
<p>os::ptr::read_volatile: <code>pub unsafe fn read_volatile&lt;T&gt;(src: *const T) -&gt; T</code>,在保持内存不变的同时易失性地读取src的值</p>
<p>core::slice::from_raw_parts: <code>pub const unsafe fn from_raw_parts&lt;&#39;a, T&gt;(data: *const T, len: usize) -&gt; &amp;&#39;a [T]</code>根据指针和长度形成切片。<code>len</code> 参数是 <strong>元素</strong> 的数量，而不是字节数。</p>
</blockquote>
<p>仔细看lazy_static的初始化内容:</p>
<ol>
<li><p>声明了一个<code>_num_app</code>符号,在同级文件夹中的link_app.S中定义,这个文件在构建操作系统时,依据os&#x2F;build.rs自动生成,内容类似下面:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_num_app:</span><br><span class="line">    .quad 7</span><br><span class="line">    .quad app_0_start</span><br><span class="line">    .quad app_1_start</span><br><span class="line">    .quad app_2_start</span><br><span class="line">    .quad app_3_start</span><br><span class="line">    .quad app_4_start</span><br><span class="line">    .quad app_5_start</span><br><span class="line">    .quad app_6_start</span><br><span class="line">    .quad app_6_end</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_0_start</span><br><span class="line">    .global app_0_end</span><br><span class="line">    app_0_start:</span><br><span class="line">    .incbin &quot;../user/build/bin/ch2b_bad_address.bin&quot;</span><br><span class="line">app_0_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_1_start</span><br><span class="line">    .global app_1_end</span><br></pre></td></tr></table></figure>

<p>由于<code>const MAX_APP_NUM: usize=16</code>,为指针切片app_start赋值时,将容纳小于此数的app个数,并将每个app的起始地址和最后一个app的结束地址存入切片</p>
</li>
<li><p>最后返回初始化成功的AppManager.这里的<code>num_app</code>的类型我有点不明白,因为对它赋值时,使用的是泛型也就是前一行的usize,然而存储0-16范围的数也需要统一使用usize吗?</p>
</li>
<li><p>调用print_app_info,依次输出app个数和每个app的内存地址</p>
</li>
</ol>
<h5 id="3-run-next-app"><a href="#3-run-next-app" class="headerlink" title="3.run_next_app"></a>3.run_next_app</h5><p>和上一小节同样在batch.rs之中,下面是来自tutorial的一段话</p>
<blockquote>
<p><code>AppManager</code> 的方法中， <code>print_app_info/get_current_app/move_to_next_app</code> 都相当简单直接，需要说明的是 <code>load_app</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run_next_app</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">app_manager</span> = APP_MANAGER.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">current_app</span> = app_manager.<span class="title function_ invoke__">get_current_app</span>();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        app_manager.<span class="title function_ invoke__">load_app</span>(current_app);</span><br><span class="line">    &#125;</span><br><span class="line">    app_manager.<span class="title function_ invoke__">move_to_next_app</span>();</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(app_manager);</span><br><span class="line">    <span class="comment">// before this we have to drop local variables related to resources manually</span></span><br><span class="line">    <span class="comment">// and release the resources</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">__restore</span>(cx_addr: <span class="type">usize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __restore(KERNEL_STACK.<span class="title function_ invoke__">push_context</span>(TrapContext::<span class="title function_ invoke__">app_init_context</span>(</span><br><span class="line">            APP_BASE_ADDRESS,</span><br><span class="line">            USER_STACK.<span class="title function_ invoke__">get_sp</span>(),</span><br><span class="line">        )) <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Unreachable in batch::run_current_app!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">load_app</span>(&amp;<span class="keyword">self</span>, app_id: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> app_id &gt;= <span class="keyword">self</span>.num_app &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;All applications completed!&quot;</span>);</span><br><span class="line">            <span class="keyword">use</span> crate::board::QEMUExit;</span><br><span class="line">            crate::board::QEMU_EXIT_HANDLE.<span class="title function_ invoke__">exit_success</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;[kernel] Loading app_&#123;&#125;&quot;</span>, app_id);</span><br><span class="line">        <span class="comment">// clear app area</span></span><br><span class="line">        core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, APP_SIZE_LIMIT).<span class="title function_ invoke__">fill</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">app_src</span> = core::slice::<span class="title function_ invoke__">from_raw_parts</span>(</span><br><span class="line">            <span class="keyword">self</span>.app_start[app_id] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>,</span><br><span class="line">            <span class="keyword">self</span>.app_start[app_id + <span class="number">1</span>] - <span class="keyword">self</span>.app_start[app_id],</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">app_dst</span> = core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, app_src.<span class="title function_ invoke__">len</span>());</span><br><span class="line">        app_dst.<span class="title function_ invoke__">copy_from_slice</span>(app_src);</span><br><span class="line">        <span class="comment">// Memory fence about fetching the instruction memory</span></span><br><span class="line">        <span class="comment">// It is guaranteed that a subsequent instruction fetch must</span></span><br><span class="line">        <span class="comment">// observes all previous writes to the instruction memory.</span></span><br><span class="line">        <span class="comment">// Therefore, fence.i must be executed after we have loaded</span></span><br><span class="line">        <span class="comment">// the code of the next app into the instruction memory.</span></span><br><span class="line">        <span class="comment">// See also: riscv non-priv spec chapter 3, &#x27;Zifencei&#x27; extension.</span></span><br><span class="line">        asm!(<span class="string">&quot;fence.i&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>load</code>本身在需要载入应用程序时,先清空约定区域的内存,将应用的二进制文件载入,再清空缓存</p>
<p><img src="/../pics/image-20240810012942659.png" alt="image-20240810012942659"></p>
<p>整体来看,调用一个app的功能实现:</p>
<ol>
<li>借来一个appManager的可变引用,方便调用它的impl</li>
<li>load 一个current 对应的app,再current+&#x3D;1,drop掉appmanager</li>
</ol>
<p>当我只看到这些时会觉得drop得有点早了,后面都在干什么?<code>__restore</code>的定义在哪里?找了一下在一个有点意外的位置:os&#x2F;src&#x2F;trap&#x2F;trap.S</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__restore:</span><br><span class="line">    # case1: start running app by __restore</span><br><span class="line">    # case2: back to U after handling trap</span><br><span class="line">    mv sp, a0</span><br><span class="line">    # now sp-&gt;kernel stack(after allocated), sscratch-&gt;user stack</span><br><span class="line">    # restore sstatus/sepc</span><br><span class="line">    ld t0, 32*8(sp)</span><br><span class="line">    ld t1, 33*8(sp)</span><br><span class="line">    ld t2, 2*8(sp)</span><br><span class="line">    csrw sstatus, t0</span><br><span class="line">    csrw sepc, t1</span><br><span class="line">    csrw sscratch, t2</span><br><span class="line">    # restore general-purpuse registers except sp/tp</span><br><span class="line">    ld x1, 1*8(sp)</span><br><span class="line">    ld x3, 3*8(sp)</span><br><span class="line">    .set n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        LOAD_GP %n</span><br><span class="line">        .set n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    # release TrapContext on kernel stack</span><br><span class="line">    addi sp, sp, 34*8</span><br><span class="line">    # now sp-&gt;kernel stack, sscratch-&gt;user stack</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    sret</span><br></pre></td></tr></table></figure>

<p>a0塞进sp,以及几个熟悉的寄存器的出现,这个<code>__restore</code>和<code>alltraps</code>太像了,功能上和<code>alltraps</code>相反,是从内核态转到用户态用的.</p>
<p>在看一眼__restore被用去干嘛:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __restore(KERNEL_STACK.<span class="title function_ invoke__">push_context</span>(TrapContext::<span class="title function_ invoke__">app_init_context</span>(</span><br><span class="line">            APP_BASE_ADDRESS,</span><br><span class="line">            USER_STACK.<span class="title function_ invoke__">get_sp</span>(),</span><br><span class="line">        )) <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Unreachable in batch::run_current_app!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>功能解释:</p>
<ol>
<li>TrapContext::app_init_context获取app起始地址和用户栈指针,用于创建TrapContext</li>
<li>KERNEL_STACK.push_context获取TrapContext本体,将它push进内核栈的栈顶,返回TrapContext的在内核栈中的可变引用</li>
<li>__restore读取TrapContext的数据并将 CPU 切换到用户模式同时恢复应用程序的状态.</li>
</ol>
<p>在<code>__restore</code>后,程序就直接跳转到了应用程序的第一行二进制指令处,后面就暂时没有内核的事了.但是,应用结束任务再调用<code>run_next_app</code>的部分还没有看到,以及具体的应用出错的处理,特权转换也有点模糊(在我脑子里)</p>
<h4 id="CodeReading-UserPart"><a href="#CodeReading-UserPart" class="headerlink" title="CodeReading-UserPart"></a>CodeReading-UserPart</h4><h5 id="1-start"><a href="#1-start" class="headerlink" title="1.__start"></a>1.__start</h5><p>位于user&#x2F;src&#x2F;lib.rs中的函数，是用户库的入口函数，也是0x80400000地址对应的最先执行的程序部分。下面是tutorial里给的案例</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="number">2</span><span class="meta">#[link_section = <span class="string">&quot;.text.entry&quot;</span>]</span></span><br><span class="line"><span class="number">3</span><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line"><span class="number">4</span>    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line"><span class="number">5</span>    <span class="title function_ invoke__">exit</span>(<span class="title function_ invoke__">main</span>());</span><br><span class="line"><span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<p>而我文件夹里的是这个样子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="meta">#[link_section = <span class="string">&quot;.text.entry&quot;</span>]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>(argc: <span class="type">usize</span>, argv: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        HEAP.<span class="title function_ invoke__">lock</span>()</span><br><span class="line">            .<span class="title function_ invoke__">init</span>(HEAP_SPACE.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> <span class="type">usize</span>, USER_HEAP_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..argc &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">str_start</span> =</span><br><span class="line">            <span class="keyword">unsafe</span> &#123; ((argv + i * core::mem::size_of::&lt;<span class="type">usize</span>&gt;()) <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">usize</span>).<span class="title function_ invoke__">read_volatile</span>() &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = (<span class="number">0usize</span>..)</span><br><span class="line">            .<span class="title function_ invoke__">find</span>(|i| <span class="keyword">unsafe</span> &#123; ((str_start + *i) <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>).<span class="title function_ invoke__">read_volatile</span>() == <span class="number">0</span> &#125;)</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        v.<span class="title function_ invoke__">push</span>(</span><br><span class="line">            core::<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(<span class="keyword">unsafe</span> &#123;</span><br><span class="line">                core::slice::<span class="title function_ invoke__">from_raw_parts</span>(str_start <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>, len)</span><br><span class="line">            &#125;)</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">exit</span>(<span class="title function_ invoke__">main</span>(argc, v.<span class="title function_ invoke__">as_slice</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多出的部分是在初始化堆、解析命令行参数（虽然现在应该没有应用需要）</p>
<p>后面exit之前进入了main函数，而因为<code>pub extern &quot;C&quot; fn </code>，main不一定是同处于lib.rs的main，得根据实际链接时bin文件中的main符号对应的main函数来看，main之中的内容暂时不看</p>
<h5 id="2-exit"><a href="#2-exit" class="headerlink" title="2.exit"></a>2.exit</h5><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exit</span>(exit_code: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    console::<span class="title function_ invoke__">flush</span>();</span><br><span class="line">    <span class="title function_ invoke__">sys_exit</span>(exit_code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上一节的_start最后调用了这个函数。这个函数内部的sys_exit是包装好的sys_call,实际上是ecall的汇编指令（类似第一章但是有区别）</p>
<p><code>ecall</code>在用户态会触发<code>Environment call from U-mode</code>的异常，会把特权从U提到S，同时直接跳转到对应的处理程序.遗憾的是还是没有发现哪里会切换到下一个应用</p>
<h5 id="3-User-Supervisor"><a href="#3-User-Supervisor" class="headerlink" title="3.User -&gt; Supervisor"></a>3.User -&gt; Supervisor</h5><p>然而exit有所谓的exit_code,再顺藤摸瓜看看谁接收这个码,发现在os&#x2F;src&#x2F;syscall&#x2F;process.rs中发现了以下神奇代码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! App management syscalls</span></span><br><span class="line"><span class="keyword">use</span> crate::batch::run_next_app;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// task exits and submit an exit code</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_exit</span>(exit_code: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    trace!(<span class="string">&quot;[kernel] Application exited with code &#123;&#125;&quot;</span>, exit_code);</span><br><span class="line">    <span class="title function_ invoke__">run_next_app</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么问题来了,是谁调用了位于内核态的sys_exit?明明前面用户态调用的sys_exit是通过ecall实现的user&#x2F;src&#x2F;syscall.rs,这两个sys_exit是怎么最后联系在一起的?</p>
<p>再看看os&#x2F;src&#x2F;syscall&#x2F;mod.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">syscall</span>(syscall_id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> syscall_id &#123;</span><br><span class="line">        SYSCALL_WRITE =&gt; <span class="title function_ invoke__">sys_write</span>(args[<span class="number">0</span>], args[<span class="number">1</span>] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>, args[<span class="number">2</span>]),</span><br><span class="line">        SYSCALL_EXIT =&gt; <span class="title function_ invoke__">sys_exit</span>(args[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">i32</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Unsupported syscall_id: &#123;&#125;&quot;</span>, syscall_id),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到syscall在内核态的包装方式,接下来在os的代码里找syscall</p>
<p>在os&#x2F;src&#x2F;trap&#x2F;mod.rs中找到结果了</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trap_handler</span>(cx: &amp;<span class="keyword">mut</span> TrapContext) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> TrapContext &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scause</span> = scause::<span class="title function_ invoke__">read</span>(); <span class="comment">// get trap cause</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stval</span> = stval::<span class="title function_ invoke__">read</span>(); <span class="comment">// get extra value</span></span><br><span class="line">    <span class="keyword">match</span> scause.<span class="title function_ invoke__">cause</span>() &#123;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::UserEnvCall) =&gt; &#123;</span><br><span class="line">            cx.sepc += <span class="number">4</span>;</span><br><span class="line">            cx.x[<span class="number">10</span>] = <span class="title function_ invoke__">syscall</span>(cx.x[<span class="number">17</span>], [cx.x[<span class="number">10</span>], cx.x[<span class="number">11</span>], cx.x[<span class="number">12</span>]]) <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::StoreFault) | Trap::<span class="title function_ invoke__">Exception</span>(Exception::StorePageFault) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] PageFault in application, kernel killed it.&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">run_next_app</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::IllegalInstruction) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] IllegalInstruction in application, kernel killed it.&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">run_next_app</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Unsupported trap &#123;:?&#125;, stval = &#123;:#x&#125;!&quot;</span>,</span><br><span class="line">                scause.<span class="title function_ invoke__">cause</span>(),</span><br><span class="line">                stval</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里发现调用了syscall</p>
<p>这个<code>trap_handler</code>就是每个应用的终点,不论是应用报错被alltraps接手,还是正常退出,从exit开始,最后都走到这里结束应用程序的生命周期.</p>
<p>整体和tutorial的内容算是一一对应,但是之前的rustlings没有这么多unsafe的指针操作和汇编,嗦实话这一章看的我好费劲T_T</p>
<h3 id="rCore-ch3"><a href="#rCore-ch3" class="headerlink" title="rCore-ch3"></a>rCore-ch3</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://luvroc.github.io">luvroc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://luvroc.github.io/2024/07/31/rCore/">http://luvroc.github.io/2024/07/31/rCore/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://luvroc.github.io" target="_blank">uloveRock?</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Embedded/">Embedded</a><a class="post-meta__tags" href="/tags/Rust/">Rust</a></div><div class="post_share"><div class="social-share" data-image="https://q1.qlogo.cn/g?b=qq&amp;nk=2316139590&amp;s=640" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/08/01/solanaNotes/" title="solanaNotes"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">solanaNotes</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/31/solana!/" title="solana资料和环境配置"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">solana资料和环境配置</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/07/31/solana!/" title="solana资料和环境配置"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-31</div><div class="title">solana资料和环境配置</div></div></a></div><div><a href="/2024/08/01/solanaNotes/" title="solanaNotes"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-01</div><div class="title">solanaNotes</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://q1.qlogo.cn/g?b=qq&amp;nk=2316139590&amp;s=640" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">luvroc</div><div class="author-info__description">dont look back in anger</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/luvroc"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">八月主要更新solana和rCore-Tutorial</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#rCore-ch1"><span class="toc-number">1.</span> <span class="toc-text">rCore-ch1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%89%A7%E8%A1%8C"><span class="toc-number">1.1.</span> <span class="toc-text">环境执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81"><span class="toc-number">1.2.</span> <span class="toc-text">用户态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%B8%E6%9C%BA%E7%8E%AF%E5%A2%83"><span class="toc-number">1.3.</span> <span class="toc-text">裸机环境</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rCore-ch2"><span class="toc-number">2.</span> <span class="toc-text">rCore-ch2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#todo-What%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">todo What？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CodeReading-CorePart"><span class="toc-number">2.2.</span> <span class="toc-text">CodeReading-CorePart</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-trap"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.trap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-batch"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.batch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-run-next-app"><span class="toc-number">2.2.3.</span> <span class="toc-text">3.run_next_app</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CodeReading-UserPart"><span class="toc-number">2.3.</span> <span class="toc-text">CodeReading-UserPart</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-start"><span class="toc-number">2.3.1.</span> <span class="toc-text">1.__start</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-exit"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.exit</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-User-Supervisor"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.User -&gt; Supervisor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rCore-ch3"><span class="toc-number">3.</span> <span class="toc-text">rCore-ch3</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/02/conclusion/" title="freshMan">freshMan</a><time datetime="2024-08-02T08:52:00.000Z" title="发表于 2024-08-02 16:52:00">2024-08-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/01/solanaNotes/" title="solanaNotes">solanaNotes</a><time datetime="2024-07-31T18:35:00.000Z" title="发表于 2024-08-01 02:35:00">2024-08-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/31/rCore/" title="rCore-Tutorial follow the riscv trend!!!">rCore-Tutorial follow the riscv trend!!!</a><time datetime="2024-07-30T18:35:00.000Z" title="发表于 2024-07-31 02:35:00">2024-07-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/31/solana!/" title="solana资料和环境配置">solana资料和环境配置</a><time datetime="2024-07-30T18:35:00.000Z" title="发表于 2024-07-31 02:35:00">2024-07-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/02/diary-1/" title="diary 1 &quot;Rememberance&quot;">diary 1 &quot;Rememberance&quot;</a><time datetime="2024-06-02T15:52:00.000Z" title="发表于 2024-06-02 23:52:00">2024-06-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By luvroc</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>